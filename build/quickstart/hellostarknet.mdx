---
title: "Creating and understanding the HelloStarknet contract"
sidebarTitle: "Creating your first contract"
---

<Warning>
If you encounter an issue while following this tutorial, check out [*Deploy your first contract* guide troubleshooting](/build/quickstart/troubleshooting/).
</Warning>

## Introduction

Welcome to the second installment of the *Deploy your first contract* guide! ðŸ¥‡

Starknet contracts are a special superset of Cairo programs that are run by the Starknet sequencer, and as such, have access to Starknet's state. This installment of the series will therefore walk you though generating and understanding Scarb's default `HelloStarknet` contract, which will be used throughout the following installments.

<Tip>
To learn more about Starknet smart contracts, see the [Cairo book](https://book.cairo-lang.org/ch100-00-introduction-to-smart-contracts.html).
</Tip>

## Creating `HelloStarknet`

Scarb's default `HelloStarknet` contract can be generated by simply running:

```bash
scarb new hello_starknet
```

and selecting to set up the `Starknet Foundry (default)` test runner. If successful, this should create a new `hello_starknet` directory with the following structure:

```
hello_starknet
|- Scarb.lock 
|- Scarb.toml 
|- snfoundry.toml 
|- src 
    |- lib.cairo
|- tests
    |- test_contract.cairo
```

## Understanding `HelloStarknet`

For the purpose of this tutorial, you can ignore all files in the `hello_starknet` directory other than `hello_starknet/src/lib.cairo`, which holds the contract's code:

```rust
/// Interface representing `HelloContract`.
/// This interface allows modification and retrieval of the contract balance.
#[starknet::interface]
pub trait IHelloStarknet<TContractState> {
    /// Increase contract balance.
    fn increase_balance(ref self: TContractState, amount: felt252);
    /// Retrieve contract balance.
    fn get_balance(self: @TContractState) -> felt252;
}

/// Simple contract for managing balance.
#[starknet::contract]
mod HelloStarknet {
    use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    struct Storage {
        balance: felt252,
    }

    #[abi(embed_v0)]
    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {
        fn increase_balance(ref self: ContractState, amount: felt252) {
            assert(amount != 0, 'Amount cannot be 0');
            self.balance.write(self.balance.read() + amount);
        }

        fn get_balance(self: @ContractState) -> felt252 {
            self.balance.read()
        }
    }
}
```

As its comments read, `HelloStarknet` is a simple contract for managing balance. Specifically:

1. The contract is defined by encapsulating state and logic within a module annotated with the `#[starknet::contract]` attribute.
2. The logic that the contract exposes to the outside world is represented by its interface trait, annotated with the `#[starknet::interface]` attribute. Here, our contract defines and publicly exposes the functions `increase_balance` and `get_balance`.
3. The state is defined within the `Storage` struct, which is always initialized empty. Here, our struct contains a single field called `balance` of type `felt252`.
4. The logic itself is defined in the implementation block and annotated with the `#[abi(embed_v0)]` attribute to expose the implementations to the outside world. Here, `increase_balance` uses the `write` method to increase `balance` by `amount` and `get_balance` uses the `read` method to return the value of `balance`.

Once deployed, each value stored in the `HelloStarknet` contract's storage will be recorded in Starknet's history.

<Tip>
To review examples of more advanced contracts, see [Starknet By Example](/build/starknet-by-example/index).
</Tip>