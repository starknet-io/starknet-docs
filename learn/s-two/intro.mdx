---
title: "Introduction to S-two"
sidebarTitle: "Introduction"
---

## Why proof systems?

At its core, proof systems can prove the validity of a statement $C(x)=y$ where $C$ is a representation of some logic, while $x$ is an input and $y$ the output of said logic.
(Assuming that we are only dealing with logic that can be expressed as a computation, we will henceforth refer to this logic as a computation).
This means that we can verify the validity of a statement by either directly running the computation, or by verifying the validity of the proof produced with the proof system.
The verifier can benefit from the second option in terms of time and space, if the time to verify the proof is faster than the time to run the computation, or the size of the proof is smaller than the input to the statement.

This property of a proof system is often referred to as **succinctness**, and it is exactly why proof systems have seen wide adoption in the blockchain space, where computation on-chain is much more expensive compared to off-chain computation.
Using a proof system, it becomes possible to replace a large collection of computation to be executed on-chain with a proof of execution of the same collection of computation and verifying it on-chain.
This way, proof generation can be handled off-chain using large machines and only the proof verification needs to be done on-chain.

But there are applications of proof systems beyond just blockchains.
Since a proof is verifiable as well as succinct, it can also be used as auxiliary data to verify that the computation of an untrusted party was done correctly.
For example, when we delegate computation to an untrusted server, we can ask it to provide a proof along with the computation result that the result indeed came from running a specific computation.
Another example could be to ask a server running an ML model to provide proof that it ran inference on the correct model.
The size of the accompanying proof and the time to verify it will be negligible compared to the cost of running the computation, but we gain the guarantee that the computation was done correctly.

Another optional feature of proof systems is **zero-knowledge**, which means that the proof reveals nothing about the computation other than its validity.
In general, the output $y$ of the computation $C(x)=y$ will be public (i.e. revealed to the verifier), but the input $x$ may be split into public and private parts, so that the verifier does not learn anything about the private part.
With this feature, the intermediate values computed by the prover while computing $C(x)$ will also be hidden from the verifier.


## Why S-two?

Before we dive into why we should choose S-two, let's define some terminology. When we talked about proof systems in the previous section, we were only referring to the part that takes a statement and outputs a proof. In reality, however, we first need to structure the statement in a way that it can be proven by the proof system. This structuring part is often referred to as the **frontend**, and the proof system is commonly called the **backend**.

With that out of the way, let's dive into some of the advantages of using S-two.

First, S-two is a standalone framework that provides both the frontend and backend and therefore handles the entire proving process. There are other frameworks that only provide the frontend or the backend, which has its advantages as its modular structure makes it possible to pick and choose a backend or frontend of one's liking. However, having a single integrated frontend and backend reduces the complexity of the system and is also easier to maintain.
In addition, S-two's frontend structures statements in the **Algebraic Intermediate Representation (AIR)**, which is a representation that is especially useful for proving statements that are repetitive (e.g. the CPU in a VM, which essentially repeats the same fetch-decode-execute over and over again).

S-two's backend is also optimized for prover performance. This is due to largely three factors.

1. It implements **STARKs**, or hash-based SNARKs, which boasts a faster prover compared to elliptic curve-based SNARKs like Groth16 or PLONK. This improvement comes mainly from running the majority of the computation in a small prime field (32 bits); Elliptic curve-based SNARKs, on the other hand, need to use big prime fields (e.g. 254-bit prime fields), which incur a lot of overhead as most computation does not require that many bits.
2. Even amongst multiple STARK backends, however, S-two provides state-of-the-art prover performance by running the **Mersenne-31 prime field** (modulo $2^{31} - 1$), which is faster than another popular 32-bit prime field like BabyBear (modulo $2^{31} - 2^{27} + 1$). We suggest going through [this post](https://blog.zksecurity.xyz/posts/circle-starks-1/) for a breakdown of why this is the case.

3. Finally, S-two offers **various CPU and GPU optimizations** that improves prover performance as shown in Figure 1 below. It can also be compiled to WASM, allowing for fast proving in web environments.

<Frame caption="Figure 1: Prover performance optimizations in S-two">
  <!-- Chart showing Stwo performance comparison would go here -->
</Frame>

One of the drawbacks of STARKs is that they have a larger proof size compared to elliptic curve-based SNARKs. One way to mitigate this drawback is by batching multiple proofs together to form a single proof.

<Note>
As of the time of this writing, S-two does not provide the "zero-knowledge" feature.
"Zero-knowledge" here refers to the fact that the proof should not reveal any additional information other than the validity of the statement, which is not true for S-two as it reveals to the verifier commitments to its witness values without hiding them by e.g. adding randomness.
This reveals some information about the witness values, which may be used in conjunction with other information to infer the witness values.
</Note>