[id="interact-contract"]
== Interact with contract

After the creation of the code to select a wallet, let's create a `PlayWithCairo` component, that will read and write the contract:

.PlayWithCairo.jsx
[source,jsx]
----
"use client";

import { useEffect, useState } from 'react';
import { type Call } from "starknet";
import { useContract, useReadContract, useSendTransaction } from '@starknet-react/core';
import TransactionStatus from './TransactionStatus';
import { counterAbi } from "../contracts/counter-abi";
import { addrTestContract, qtyForIncrease } from '@/app/utils/constants';


export default function PlayWithCairo() {
    const [transactionHash, setTransactionHash] = useState<string>("");
    const [getCounter, setCounter] = useState<bigint | undefined>(undefined);

    const { contract } = useContract({ abi: counterAbi, address: addrTestContract });
    const { sendAsync, data, status, isSuccess } = useSendTransaction({ calls: [] });
    const { data: counter } = useReadContract({
        address: addrTestContract,
        abi: counterAbi,
        functionName: "get_counter",
        args: [],
        // watch: true, // refreshed each block, or `refetchInterval`
        refetchInterval: 30_000 // ms
    });

    async function increaseCounter() {
        if (contract) {
            const myCall: Call = contract.populate("increase_counter", [qtyForIncrease]);
            const response = await sendAsync([myCall]);
            setTransactionHash(response.transaction_hash);
            // Do not wait to update the display
            setCounter((getCounter ?? 0n) + BigInt(qtyForIncrease));
        }
    }

    useEffect(
        () => {
            setCounter(typeof counter === undefined ? undefined : BigInt(counter ?? 0n));
            return () => { }
        },
        [counter]
    );


    return (
        <div style={{
            backgroundColor: 'mediumaquamarine',
            color: 'black',
            borderWidth: '1px',
            borderRadius: 'md',
            paddingBottom: '3px',
            marginBottom: 20,
        }}
        >
            {
                typeof getCounter === undefined ? (
                    <div className='normalTextBlack' style={{ textAlign: "center" }}>
                        Fetching data ...
                    </div>
                ) : (
                    <>
                        <div
                            className='normalTextBlack'
                            style={{
                                textAlign: "center",
                                paddingTop: "4px",
                                paddingBottom: "2px",
                            }}>
                            <p style={{ fontSize: "19px" }}>
                                Counter = {(getCounter ?? "???").toString()}
                            </p>
                            <div style={{ textAlign: "center", paddingBottom: "6px" }}>
                                <button
                                    className='myButton'
                                    style={{ marginTop: "6px" }}
                                    onClick={() => {
                                        increaseCounter();
                                    }}
                                >
                                    Increase counter (+{qtyForIncrease.toString()})
                                </button>
                            </div>
                        </div>
                        {!!transactionHash && (
                            <div style={{
                                textAlign: "center",
                                backgroundColor: 'rgb(162, 244, 172)',
                                color: "black",
                                border: "3px solid rgb(29, 113, 34)",
                                borderRadius: "9px",
                                padding: 1,
                                margin: 2,
                            }}
                            >
                                <TransactionStatus transactionHash={transactionHash}></TransactionStatus>
                            </div>
                        )
                        }
                    </>
                )
            }
        </div>
    )
}
----

We have here 3 important hooks :

* useReadContract()
+
[source,jsx]
----
const { data } = useReadContract({
    address: addrTestContract,
    abi: counterAbi,
    functionName: "get_counter",
    args: [],
    refetchInterval: 30_000 // ms
});
----
This hook is calling a contract function that returns data from the blockchain. +
You needs in this hook the xref:architecture-and-concepts:smart-contracts/contract-abi.adoc[ABI] of the contract ; you will find it inside the Sierra file generated by the compilation of the contract. In our project, find the ABI section in `target/dev/counter_test_session.contract_class.json`, at the end of the file. +
Create in the DAPP project a new file `contracts/counter-abi.ts`. Start the file with
+
[source,jsx]
----
export const counterAbi = 
----
Then paste the array that includes all the elements of the ABI.
The result is something like this :
+
.counter-abi.ts
[source,jsx]
----
export const counterAbi = [
  {
    "type": "impl",
    "name": "TestSession",
    "interface_name": "counter::ITestSession"
  },
  {
    "type": "interface",
    "name": "counter::ITestSession",
    "items": [
      {
        "type": "function",
        "name": "increase_counter",
        "inputs": [
          {
            "name": "value",
            "type": "core::integer::u128"
          }
        ],
        "outputs": [],
        "state_mutability": "external"
      },
      ......
      ......
  }
] 
----
The result of the reading of the Starknet contract is in the `data` variable. This hook is executed at the opening of the component. 
+
--
** With the `watch: true` option, the request is repeated each block. 
** With the `refetchInterval: value` option, the request is repeated each `value` milliseconds. To use with caution, to not overload your Starknet access. 
--
+
This hook needs also the address of the contract. Create a `utils/constants.ts` file including:
+
.constants.ts
[source,ts]
----
export const addrTestContract ="0x363d42397f536706e7b2a9883ec8d4db739f062ac6aab8ade02b7db8cede731" as const; // sepolia testnet
export const qtyForIncrease: number = 10 as const;
----
+
[NOTE]
====
Adapt the address to your contract deployment.
====

[#useContract]
* useContract()
+
[source,jsx]
----
const { contract } = useContract({ 
    abi: counterAbi, 
    address: addrTestContract
});
----
This hook is useful to create a https://starknetjs.com/docs/next/guides/define_call_message#call-or-call[Call], that will be used to write in Starknet network:
+
[source, jsx]
----
const myCall: Call = contract.populate("increase_counter", [qtyForIncrease]);
----

* useSendTransaction()
+ 
[source,jsx]
----
const { sendAsync } = useSendTransaction({ calls: [] });
----
This hook executes the functions of the contract that are writing in Starknet. +
`sendAsync` needs as input one or several `Calls`, created with the previous xref:#useContract[hook].
+ 
[source,jsx]
----
const response = await sendAsync([myCall]);
----

Finally, create a last `TransactionStatus` component, that will verify if the transaction has been properly processed:

.TransactionStatus.tsx
[source,jsx]
----
"use client";

import { GetTransactionReceiptResponse, json, type RejectedTransactionReceiptResponse, type RevertedTransactionReceiptResponse, type SuccessfulTransactionReceiptResponse } from "starknet";
import { useTransactionReceipt } from '@starknet-react/core';

type Props = { transactionHash: string };

export default function TransactionStatus({ transactionHash }: Props) {
    const { data: txR } = useTransactionReceipt({ hash: transactionHash, refetchInterval: 5_000 });

    function formatTxR(txR: GetTransactionReceiptResponse): string {
        let finality: string = "";
        txR.match({
            success: (txR: SuccessfulTransactionReceiptResponse) => {
                finality = txR.finality_status;
            },
            rejected: (txR: RejectedTransactionReceiptResponse) => {
                finality = json.stringify(txR.transaction_failure_reason);
            },
            reverted: (txR: RevertedTransactionReceiptResponse) => {
                finality = txR.finality_status;
            },
            error: (err: Error) => {
                finality = err.message;
            },
            _: () => {
                console.log('Unsuccessful');
            },
        });
        return txR.statusReceipt + "â†’" + finality;
    }


    return (
        <>
            <div 
            className="normalTextBlack" 
            style={{
                padding:"4px", 
                margin:"5px",
            }}>Transaction is : {" "}
                {!txR ?
                    <>Processing</>
                    : formatTxR(txR)}
            </div>
        </>
    )
}
----

Our last Starknet hook:
[source,jsx]
----
const { data } = useTransactionReceipt({ hash: transactionHash, refetchInterval: 5_000 });
----

The `useTransactionReceipt` hook will report each 5 seconds in `data` a refreshed transaction report object.

The DAPP code is ready. Test it with:

[source,bash]
----
npm run dev
----

and  open the displayed link in your browser. Connect an installed wallet, click on the button to increase the counter, approve the transaction in the wallet, and you have the result on the screen:

image::counter-dapp:screenshot-dapp.png[]

**You just built a fullstack dapp on Starknet!**

https://github.com/PhilippeR26/Starknet-Counter-DAPP/tree/main/src/app[Here is the repo for this project]

If you run into any problems, a good first step is to compare your code to this repo and resolve any differences.

If necessary, you can contact the assistance team in the Starknet Discord https://discord.com/channels/793094838509764618/1270119831559078061[here].