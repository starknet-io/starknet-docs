= Staking protocol

[IMPORTANT]
====
This page is a deep-dive into Starknet's staking protocol. To learn how to stake on Starknet, go to xref:staking:overview.adoc[Guides].
====

== Introduction

While Starknet is currently still centralized, it is moving towards employing a xref:#protocol[staking protocol], handing over the responsibilities of maintaining and securing Starknet by producing, attesting, and proving blocks to validators. Naturally, handing over these responsibilities in one day is neither feasible nor desirable. Instead, the PoS protocol is be implemented in four incremental phases, illustrated in following figure:

image::staking-roadmap.png[]

To facilitate this, the protocol's architecture is modular, with each xref:#components[component] handling specific responsibilities, ensuring maximum flexibility and ease of upgrades.

== Protocol

The following sections describe the details of Starknet's staking protocol. The parameters used in the protocol are summarized in the following table:

[%autowidth]
|===
| Parameter | Value

| Minimum stake for validators
| 20K STRK (1 STRK on Sepolia)

| Epoch size (stem:[E])
| 100-1,000 Blocks

| The block window range to submit an attestation (stem:[W])	
| 16 - 30 Blocks

| Number of epochs used for latency (stem:[k])
| 1	

| Minting curve yearly inflation cap (stem:[C])
| 1.6 (same on Sepolia)

| Withdrawal security lockup
| 21 days (5 minutes on Sepolia)
|===

=== Roles

Starknet's staking protocol features two options for participation:

* Staking directly as validators: Staking a minimum of 20,000 STRK and earning rewards by handling any responsibilities the protocol requires

* Staking indirectly as delegators: Delegating STRKs to validators who alloe delegation and sharing in their rewards without handling any of their responsibilities
+
[IMPORTANT]
====
Validators can choose whether to allow delegation or not.
====

=== Ephocs

Naturally, the more stake a validator has, the more blocks they should produce. However, applying changes in validators' stakes immediately can #make things unpredictable#. To resolve this, the second phase of the staking protocol introduces the notion of epochs (similarly to many other protocols).

Epochs represent checkpoints where validators' stakes are set, such that changes made in epoch stem:[i] are applied in epoch stem:[i+k], where stem:[k] is a new latency parameter. 

[NOTE]
====
As long as validators are not yet producing blocks, stem:[k] may be equal to 1. When validators also produce blocks, stem:[k] will have to be greater than 1, as the producer of the first block of epoch stem:[j] will have to be known before the last block of epoch stem:[j-1].
====

For example, the following figure illustrates a scenario where in epoch stem:[i] validator stem:[A] has 50K STRK staked and someone delegates an additional 10K STRK to them, and in epoch stem:[i+1] someone undelegates 30K STRK from stem:[A]:

image::epochs-example.png[]

=== Responsibilities

// ==== Running a full node

==== Block attestation

The primary change in the second phase of the staking protocol, is the introduction of a block attestation mechanism for validators. In each epoch, each validator is assigned a single block whose relative number within the epoch is defined as follows:

[stem]
++++
h(\text{staked amount},\text{epoch id},\text{validator address}) \mod (E-W)
++++

where:

* stem:[E] is the number of blocks in an epoch, termed _epoch length_
* stem:[W] is the number of blocks applicable for attestation submittal, termed _attestation window_

During each epoch, validators have the opportunity to attest to their assigned block by submitting an `attest` transaction, which must be included within the attestation window. For example, if stem:[W = 20] and stem:[N] is the relative block number assigned to validator stem:[A], then stem:[A] must submit an `attest` transaction between block stem:[N+1] to stem:[N+20]. Each Validator is required to perform only one attestation per epoch.

The `attest` transaction includes the block hash of the attested block, ensuring validators actively use full nodes, as they need to continuously track block hashes. Additionally, the attestation is publicly verifiable, ensuring validators' reliability is publicly tested — a crucial prerequisite before handing them any core responsibilities.

// Note that each validator is required to perform only one attestation per epoch, and therefore the work is identical for all validators. This is done in the interest of simplifying the implementation of the protocol's second phase, saving time and effort for the later phases. In any case, the main cost and effort is running a full node, which is obligatory for all validators.

=== Rewards

Rewards are distributed based on the amount staked and the commission policy constant stem:[CP] set by the validator. The yearly reward percentages are calculated using the following formulas:

* For delegators:
+
[stem]
++++
\text{stake_delegated} \cdot (1 - CP) \cdot \frac{M}{S}
++++

* For validators:
+
[stem]
++++
\left(\text{self_stake} + \text{total_stake_delegated} \cdot CP\right) \cdot \frac{M}{S}
++++

where stem:[M] and stem:[S] are defined by the xref:#minting_curve[].

Starting from the second phase of the staking protocol, rewards are accumulated per epoch only for validators who performed their attestations in the epoch on an “all or nothing” basis — so validators that submitted a transaction during the epoch that proves they tracked the network will receive all the rewards for the epoch based on their staked amount, while validators that didn't will get no rewards for the epoch's entire duration. After performing the attestation, the rewards that go directly to the validator will accumulate in his account, and the rest will go to this validator's pool.

[NOTE]
====
The global index of rewards was removed in the second phase of the staking protocol. Instead, when a delegator claims his rewards, all rewards they received from all epochs since the last time they claimed rewards will be accumulated. The complexity of this operation is stem:[O(\text{#delegator's balance changes since last claim})] — and not stem:[O(\text{#epochs since last claim})] — which is assumed to be small enough to fit in one transaction in any real-world-scenario.
====

==== Minting curve

The minting curve balances participation and inflation by adjusting rewards based on the total STRK locked in the protocol. It is defined by the following formula:

[stem]
++++
M = \frac{C}{10} \times \sqrt{S}
++++

where:

* stem:[S] is the staking rate as a percentage of the total token supply
* stem:[M] is the annual minting rate as a percentage of the total token supply
* stem:[C] is the maximum theoretical inflation percentage, currently set to 1.6%

=== Latencies

Funds are subject to a 21-day security lockup after signaling an unstake intent, but delegators can switch between validators without waiting for the full lockup period*, promoting a competitive delegation market.

Starting phase 2, entry and exit latencies are determined by xref:epochs[ephocs].

== Components

[TIP]
====
For more technical details, you can refer to the full staking specification document available in: https://github.com/starkware-libs/starknet-staking/blob/main/docs/spec.md[Staking Repository Spec].
====

The implementation of Starknet's staking protocol is divided into several contracts, summarized in the following figure:

image::staking-architecture.png[]

This modular architecture allows for targeted upgrades and improvements without affecting the entire system. Access control mechanisms are also in place to ensure that only authorized parties can make critical changes, further enhancing the security of the staking process.

=== Staking contract

The staking contract is the core of the staking system, managing the entire lifecycle of staking, from initial staking to claiming rewards and unstaking. Its key functions include:

* `stake`: Allows users to stake their STRK tokens
* `increase_stake`: Allows existing validators to increase their stake
* `unstake_intent`: Initiates the unstaking process
* `unstake_action`: Finalizes the unstaking process, returning tokens to the validator address
* `claim_rewards`: Allows users to claim rewards

[NOTE]
====
The staking contract stores the `StakerInfo` data structure, which holds detailed information about each validator, including their staked amount, unclaimed rewards, delegation details, and operational parameters, and helps to ensure that validators' information is accurately tracked and updated.
====

=== Delegation pooling contract

All delegation interactions, such as entering or exiting a pool, are enabled through the delegation pooling contract, which tracks each delegator's contribution, calculates their rewards, and manages the delegation lifecycle. Its key functions are:

* `enter_delegation_pool`: Allows users to delegate their tokens to the pool associated with a validator. This function transfers the tokens, updates the delegator's record, and integrates them into the validator's pool.

* `add_to_delegation_pool`: Enables existing delegators to increase their delegation amount. The contract updates the pool's total and recalculates the member's rewards.

* `exit_delegation_pool_intent`: Initiates the process for a delegator to exit the pool. Similar to validators, the delegator's funds are locked for a period before they can be withdrawn.

* `exit_delegation_pool_action`: Finalizes the exit process for a delegator, returning their tokens and any unclaimed rewards.

* `switch_delegation_pool`: Allows a delegator to transfer their delegated stake from one validator's pool to another, facilitating dynamic delegation strategies.

* `claim_rewards`: Transfers the delegator's earned rewards to their specified reward address.

[NOTE]
====
The delegation pooling contract stores the `PoolMemberInfo` data structure, which holds information about each delegator's contributions, rewards, and status within the pool, and helps manage and calculate the delegation and reward distribution processes for pool members.
====

=== Reward Supplier Contract

The reward supplier contract is responsible for calculating and supplying the staking rewards based on the minting curve, ensuring the rewards are distributed fairly and in accordance with the protocol's economic parameters. Its key Functions are:

* `calculate_staking_rewards`: Computes the rewards based on the current staking rate and the minting curve, updating the staking contract with the amount to be distributed.

* `claim_rewards`: Handles the transfer of rewards to the staking contract, ensuring that the correct amount is distributed to validators and delegators.

=== Minting Curve Contract

The minting curve contract defines the economic model that governs reward distribution, ensuring the network's inflation is managed while incentivizing participation in staking. Its key functions are:

* `yearly_mint`: Returns the amount of STRK tokens to be minted annually based on the current staking rate. This function uses a square root formula to balance rewards and inflation.

* `update_total_supply`: Updates the total supply of STRK tokens, ensuring that the minting calculations remain accurate.