= Contracts

== Introduction

Starknet contracts are a special superset of Cairo programs that are run by the Starknet sequencer, and as such, have access to Starknet's state. As in object-oriented programming, Starknet distinguishes between a contract and its implementation by separating contracts into xref:contract_classes[classes] and xref:contract_instances[instances]: A contract class is the definition of a contract, while a contract instance is a deployed contract that corresponds to a class. Only contract instances act as true contracts, in that they have their own storage and can be called by transactions or other contracts.

[NOTE]
====
A contract class does not necessarily require a deployed instance in Starknet.
====

.Additional resources
* https://book.cairo-lang.org/ch100-00-introduction-to-smart-contracts.html[_Smart Contracts in Cairo_ in the Cairo Book^]
* xref:smart-contracts/cairo-and-sierra.adoc[]
* xref:network-architecture/starknet-state.adoc[]

== Contract classes

=== Components of a Cairo class definition

The components that define a class are:

[cols="1,3a"]
|===
| Component name | Notes

| Contract class version
| The version of the contract class object. Currently, the Starknet OS supports version 0.1.0

| Array of external functions entry points
a| An entry point is a pair `(_selector_, _function_idx_)`, where `_function_idx_` is the index of the function inside the Sierra program.

[NOTE]
====
The selector is an identifier through which the function is callable in transactions or in other classes. The selector is the xref:../cryptography.adoc#starknet_keccak[starknet_keccak] hash of the function name, encoded in ASCII.
====

| Array of xref:architecture-and-concepts:network-architecture/messaging-mechanism.adoc#l1-l2-message-fees[L1 handlers] entry points
| -

| Array of constructors entry points
| Currently, the compiler allows only one constructor.

| ABI
a| A string representing the ABI of the class. The ABI hash (which affects the class hash) is given by:
[source,python]
----
starknet_keccak(bytes(ABI, "UTF-8"))
----
[NOTE]
====
This string is supplied by the user declaring the class (and is signed on as part of the `DECLARE` transaction), and is not enforced to be the true ABI of the associated class.
Without seeing the underlying source code (i.e. the Cairo code generating the class's Sierra), this ABI should be treated as the "intended" ABI by the declaring party, which may be incorrect (intentionally or otherwise).
The "honest" string would be the json serialization of the contract's ABI as produced by the Cairo compiler.
====

| Sierra program
| An array of field elements representing the Sierra instructions.
|===

=== Class hash

Each class is uniquely identified by its _class hash_, comparable to a class name in traditional object-oriented programming languages. The hash of the class is the chain hash of its components, computed as follows:

[source,cairo]
----
class_hash = h(
    contract_class_version,
    external_entry_points,
    l1_handler_entry_points,
    constructor_entry_points,
    abi_hash,
    sierra_program_hash
)
----

Where

* stem:[$h$] is the xref:../cryptography.adoc#poseidon_hash[Poseidon] hash function
* The hash of an entry point array stem:[$(selector,index)_{i=1}^n$] is given by stem:[$h(\text{selector}_1,\text{index}_1,...,\text{selector}_n,\text{index}_n)$]
* The `sierra_program_hash` is the xref:../cryptography.adoc#poseidon_hash[Poseidon] hash of the bytecode array

[NOTE]
====
The Starknet OS currently supports contract class version 0.1.0, which is represented in the above hash computation as the ASCII encoding of the string `CONTRACT_CLASS_V0.1.0` (hashing the version in this manner gives us domain separation between
the hashes of classes and other objects).
====

For more details, see the https://github.com/starkware-libs/cairo-lang/blob/7712b21fc3b1cb02321a58d0c0579f5370147a8b/src/starkware/starknet/core/os/contracts.cairo#L47[Cairo implementation].

// ==== Compiled class hash

// The compiled class hash is a cryptographic hash that results from the compilation process of a Cairo class from its intermediate representation (Sierra) to Cairo assembly (Casm). This process is managed by the Sierra→Casm compiler.

// The compiled class hash is crucial for ensuring the uniqueness and integrity of compiled classes within Starknet. Whether you are a developer deploying contracts or a party interested in the inner workings of Starknet's state commitment, understanding the compiled class hash is essential.

// For developers, the hash is an important part of the contract declaration process, ensuring that each compiled class is uniquely identifiable and verifiable. For those involved in maintaining the network, it contributes to the efficiency and performance of Starknet by optimizing the state commitment process.

// The state commitment uses the Sierra code that results when compiling Cairo classes. Sierra acts as an intermediate representation between Cairo and Casm. Provers, however, operate solely with Casm.

// In order to avoid recompiling, from Sierra to Casm, each block in which the class is deployed, the state commitment gets the information it needs about the corresponding Casm from the information contained in the compiled class hash.

// When declaring a contract, the party administering the contract endorses the compiled class hash, procured using an SDK, as an integral component of the xref:network-architecture/transactions.adoc#declare_v2[`DECLARE`] transaction. Following the inclusion of the transaction in a block, the compiled class hash integrates into the state commitment.

// .Purpose and Significance

// * Uniqueness: The compiled class hash ensures the uniqueness of each compiled class. It is essentially a fingerprint for the compiled output, allowing the network to verify the integrity and uniqueness of the class.

// * State Commitment: In Starknet, state commitment includes various components, including the Cairo classes. These classes are initially defined using Sierra. However, for the prover to function efficiently, it requires Casm.

// * Efficiency: By including the compiled class hash in the state commitment, Starknet avoids the need to recompile from Sierra to Casm in every block where the class is used. This optimization significantly enhances the network’s efficiency and performance.

// .Usage

// When a new contract is declared on Starknet, the compiled class hash plays a pivotal role. Here's how:

// * Declaration Process: The party declaring the contract computes the compiled class hash using an SDK provided by Starknet.

// * DECLARE Transaction: This hash is then included as part of the xref:network-architecture/transactions.adoc#declare_v2[`DECLARE`] transaction is a specific type of transaction in Starknet used to register new contracts.

// * Inclusion in State Commitment: Once the xref:network-architecture/transactions.adoc#declare_v2[`DECLARE`] transaction is included in a block, the compiled class hash becomes part of the state commitment. This inclusion ensures that the network recognizes and stores the unique compiled output of the contract.

// Prospectively, as Sierra-to-Casm compilation integrates into the Starknet OS, the value might undergo updates via proof of the Sierra-to-Casm compiler execution. Such verification demonstrates that compiling the same class with an updated compiler version yields a fresh compiled class hash.
// The compiled class hash is a basic element in Starknet’s architecture, enabling efficient state commitment and ensuring the integrity and uniqueness of compiled classes.

=== Working with classes

[horizontal,labelwidth=20]
Adding new classes:: To introduce new classes to Starknet's state, use the `DECLARE` transaction.

Deploying instances:: To deploy a new instance of a previously declared class, use the `deploy` system call.

Using class functionality:: To use the functionality of a declared class without deploying an instance, use the `library_call` system call. Analogous to Ethereum's `delegatecall`, it enables you to use code in an existing class without deploying a contract instance.

== Contract instances

== Contract nonce

A contract instance has a nonce, the value of which is the number of transactions originating from this address plus 1. For example, when you deploy an account with a `DEPLOY_ACCOUNT` transaction, the nonce of the account contract in the transaction is `0`. After the `DEPLOY_ACCOUNT` transaction, until the account contract sends its next transaction, the nonce is `1`.

=== Contract address

The contract address is a unique identifier of the contract on Starknet. It is a chain hash of the following information:

[horizontal,labelwidth="26"]
`prefix`:: The ASCII encoding of the constant string `STARKNET_CONTRACT_ADDRESS`.
`deployer_address`:: One of the following:
* When the contract is deployed via a `DEPLOY_ACCOUNT` transaction: `0`
* When the contract is deployed via a `deploy` system call from another contract, the value of the `deploy_from_zero` parameter determines this value.
+
For information on the `deploy_from_zero` parameter, see the xref:smart-contracts/system-calls-cairo1.adoc#deploy[`deploy` system call]
`salt`:: The salt passed by the contract calling the syscall, provided by the transaction sender.
`class_hash`:: See xref:class_hash[].
`constructor_calldata_hash`:: xref:cryptography.adoc#pedersen_array_hash[Array hash] of the inputs to the constructor.

The address is computed as follows:

[source,]
----
contract_address = pedersen(
    “STARKNET_CONTRACT_ADDRESS”,
    deployer_address,
    salt,
    class_hash,
    constructor_calldata_hash)
----

[NOTE]
====
A random `salt` ensures unique addresses for smart contract deployments, preventing conflicts when deploying identical contract classes.

It also thwarts replay attacks by influencing the transaction hash with a unique sender address.
====

[TIP]
====
For more information on the address computation, see https://github.com/starkware-libs/cairo/blob/2c96b181a6debe9a564b51dbeaaf48fa75808d53/corelib/src/starknet/contract_address.cairo[`contract_address.cairo`^] in the Cairo GitHub repository.
====
