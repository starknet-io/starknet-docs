Starknet employs a class-based structure, akin to object-oriented programming, to separate contracts into classes and instances.

== Contract Classes

A **contract class** serves as the blueprint for a contract, encapsulating Cairo bytecode, hint information, entry point names, and everything defining its unambiguous semantics.

Each class is uniquely identified by its **class hash**, comparable to a class name in traditional object-oriented programming languages.

== Contract Instances

A **contract instance** represents a deployed contract corresponding to a class. Only instances of contracts act as true contracts, possessing their storage and being callable by transactions or other contracts.

It's essential to note that a contract class doesn't necessarily require a deployed instance in Starknet.

== Working with Classes

*Adding New Classes:* To introduce new classes to Starknet's state, leverage the `declare` transaction.

*Deploying Instances:* For deploying new instances of a previously declared class, utilize the `deploy` system call.

*Using Class Functionality:* If you wish to use the functionality of a declared class without deploying an instance, the `library_call` system call is your ally. Analogous to Ethereum's `delegatecall`, it allows direct use of class code without deploying a placeholder contract solely for its code.

== Additional Resources

- **Class Hash**
- [Starknet Declare Transaction](link-to-declare-transaction-doc)
- [Starknet Deploy System Call](link-to-deploy-system-call-doc)
- [Starknet Library_Call System Call](link-to-library-call-doc)

Remember to replace `[link-to-declare-transaction-doc]`, `[link-to-deploy-system-call-doc]`, and `[link-to-library-call-doc]` with the actual documentation links or relevant resources.
