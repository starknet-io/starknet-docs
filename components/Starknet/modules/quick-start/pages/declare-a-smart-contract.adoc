= Declaring the `HelloStarknet` contract on Starknet Sepolia

== Introduction

Welcome to the third installment of the "Hello, Starknet!" quickstart series, the official tutorial for starting your journey as a Starknet developer! ðŸš€

Before a contract can be deployed on Starknet, it first needs to be _declared_. Declaration is the process of submitting a contract's code to Starknet and making it available for future deployments (analogous to registering its blueprint). This installment of the series will therefore guide you through the steps necessary to declare Scarb's default `HelloStarknet` contract on Starknet Sepolia.

[TIP]
====
For more details on declaration and its benefits, see xref:architecture-and-concepts:smart-contracts/contract-classes.adoc[Contract classes and instances].
====

== Generating `HelloStarknet`

Scarb's default `HelloStarknet` contract can be generated by simply running:

[source,console]
----
$ scarb new hello_starknet
----

and select the default Starknet Foundry as a test runner.

For the purpose of this tutorial, you can ignore all files in the `hello_starknet` directory other than `hello_starknet/src/lib.cairo`, which holds the contract's code:

[#example-cairo-contract]
[source,cairo]
----
/// Interface representing `HelloContract`.
/// This interface allows modification and retrieval of the contract balance.
#[starknet::interface]
pub trait IHelloStarknet<TContractState> {
    /// Increase contract balance.
    fn increase_balance(ref self: TContractState, amount: felt252);
    /// Retrieve contract balance.
    fn get_balance(self: @TContractState) -> felt252;
}

/// Simple contract for managing balance.
#[starknet::contract]
mod HelloStarknet {
    use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    struct Storage {
        balance: felt252,
    }

    #[abi(embed_v0)]
    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {
        fn increase_balance(ref self: ContractState, amount: felt252) {
            assert(amount != 0, 'Amount cannot be 0');
            self.balance.write(self.balance.read() + amount);
        }

        fn get_balance(self: @ContractState) -> felt252 {
            self.balance.read()
        }
    }
}
----

As the comments read, this is a simple contract allowing modification and retrieval of its balance.

== Compiling `HelloStarknet`

Before a smart contract can be declared, it first needs to be compiled. To compile the `HelloStarknet` contract, navigate into the `starknet_quickstart` directory and run:

[source,console]
----
$ scarb build
----

[NOTE]
====
Building a Starknet Foundry project with Scarb requires https://www.rust-lang.org/[Rust] to be installed. You can verify that Rust is installed and up-to-date by running:

    rustc --version

or install the latest Rust version by following the instructions in the https://doc.rust-lang.org/beta/book/ch01-01-installation.html[Rust documentation].

Moreover, the first time a project is built, some components of Scarb are compiled locally with the Rust toolchain. This process may take a few minutes, but will not happen in subsequent builds.
====

The compiled contract should be saved inside the `hello_starknet/target/dev/` directory as `hello_starknet_HelloStarknet.contract_class.json`.

== Declaring `HelloStarknet` on Sepolia

Now that the `HelloStarknet` contract has been compiled, it can be declared on Starknet Sepolia by navigating into the `hello_starknet` directory and running:

[source,console]
----
$ starkli declare target/dev/hello_starknet_HelloStarknet.contract_class.json --network=sepolia
----

[NOTE]
====
When using `starkli declare`, Starkli will do its best to identify the compiler version of the declared class. In case it fails, the `--compiler-version` flag can be used to specify the version of the compiler as follows:

. Find the compiler versions supported by Starkli by running:
+
[source,console]
----
$ starkli declare --help 
----
+
and looking for the possible values of the `--compiler-version` flag.

. Find the current Scarb version in use:
+
[source,console]
----
$ scarb --version
----

. In case a different compiler version is required, switch to a different Scarb version using `asdf`:

.. Install the desired Scarb version:
+
[source,console]
----
$ asdf install scarb <VERSION>
----

.. Select the desired Scarb version as the local version for the project:
+
[source,console]
----
$ asdf local scarb <VERSION>
----

.. Declare the contract with the desired Scarb version:
+
[source,console]
----
$ starkli declare target/dev/hello_starknet_HelloStarknet.contract_class.json \
    --compiler-version=<VERSION> \
    --network=sepolia
----
====

The output of a successful contract declaration using Starkli should resemble the following:

[source,console]
----
Class hash declared: 
0x0785c92bf4aa7a89fb62371802aef2f58e2333d8df7e2aadf938efa83735431c
----

However, Starkli's output for the declaring `HelloStarknet` on Starknet Sepolia should resemble the following:

[source,console]
----
Not declaring class as its already declared. Class hash:
0x0785c92bf4aa7a89fb62371802aef2f58e2333d8df7e2aadf938efa83735431c
----

This is because declaration is a one-time process for each unique contract code, and `HelloStarknet` has already been declared on Starknet Sepolia.

In both cases, however, you should be able to see the declared contract on one of xref:tools:ref-block-explorers.adoc[Starknet Sepolia's block explorers] by searching for its class hash (which is its unique identifier).

