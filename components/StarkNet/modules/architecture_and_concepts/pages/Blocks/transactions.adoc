[id="transaction_structure"]
= Transaction structure

StarkNet supports the following types of transactions:

* _invoke_ transaction
* _declare_ transaction

This topic describes the available fields for these transaction types and how each transaction hash is calculated.

[IMPORTANT]
====
The deploy transaction has now been removed in the current release of StarkNet. To deploy new contract instances, you can use the `deploy` syscall.
====

[id="transaction_versioning"]
== Transaction versioning

StarkNet supports the transaction versions described here.

When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases.

Do not submit a transaction that uses an unsupported transaction type, because it cannot be included in a proof, and so cannot become part of a StarkNet block.

[id="deploy_transaction"]

=== Calculating the hash of a deploy transaction

In order to calculate the transaction hash, we first need to obtain the deployed contract address. The Deploy transaction's hash is calculated as follows:

[stem]
++++
\begin{aligned}
\text{deploy_tx_hash} = h( & ``\text{deploy"}, \text{version}, \text{ contract_address}, \text{sn_keccak}(``\text{constructor"}), \\
& h(\text{constructor_calldata}), 0, \text{chain_id})
\end{aligned}
++++

Where:

* The placeholder zero is used to align the hash computation for the different types of transactions.
* “deploy” and “constructor” are constant strings encoded in ASCII.
* stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen-hash[Pedersen] hash and stem:[$sn\_keccak$] is xref:../Hashing/hash-functions.adoc#starknet-keccak[StarkNet Keccak]
* `chain_id` is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id].
* `contract_address` is calculated as described xref:../Contracts/contract-address.adoc[here].

== Invoke Transaction

The invoke transaction is the main transaction type used to invoke contract functions in StarkNet.

[IMPORTANT]
====
Transaction version 0 is deprecated and will be removed in a future release of StarkNet.
====

=== Invoke transaction version 1

.Transaction fields

[%autowidth]
|===
| Name | Type | Description

| `sender_address` | `FieldElement` | The address of the sender of this transaction.
| `calldata` | `List<FieldElement>` | The arguments that are passed to the `validate` and `execute` functions.
| `signature` | `List<FieldElement>` | Additional information given by the sender, used to validate the transaction.
| `max_fee` | `FieldElement` | The maximum fee that the sender is willing to pay for the transaction
| `nonce` | `FieldElement` | The transaction nonce.
| `version` | `FieldElement` | The transaction's version. The value is 1. +
When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases.
|===

=== Invoke transaction version 0

.Transaction fields
[%autowidth]
|===
| Name | Type | Description

| `contract_address` | `FieldElement` | The address of the contract invoked by this transaction.
| `entry_point_selector` | `FieldElement` | The encoding of the selector for the function invoked (the entry point in the contract)
| `calldata` | `List<FieldElement>` | The arguments that are passed to the invoked function
| `signature` | `List<FieldElement>` | Additional information given by the sender, used to validate the transaction.
| `max_fee` | `FieldElement` | The maximum fee that the sender is willing to pay for the transaction
| `version` | `FieldElement` | The transaction's version. The value is 0. +
Transaction version 0 is deprecated and will be removed in a future version of StarkNet. +
When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases.
|===

=== Calculating the hash of a v1 invoke transaction

The invoke transaction hash is calculated as a hash over the given transaction elements, specifically:

[stem]
++++
\begin{aligned}
\text{invoke_v1_tx_hash} = h( & ``\text{invoke"}, \text{version}, \text{sender_address}, 0, h(\text{calldata}), \\
& \text{max_fee}, \text{chain_id}, \text{nonce})
\end{aligned}
++++

Where:

* stem:[\text{invoke}] is a constant prefix string, encoded in ASCII.
* The placeholder zero is used to align the hash computation for the different types of transactions.
* stem:[\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id].
* stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen-hash[Pedersen] hash

=== Calculating the hash of a v0 invoke transaction

The hash of a v0 invoke transaction is computed as follows:

[stem]
++++
\begin{aligned}
\text{invoke_v0_tx_hash} = h( & ``\text{invoke"}, \text{version}, \text{contract_address}, \text{entry_point_selector}, \\
& h(\text{calldata}), \text{max_fee}, \text{chain_id})
\end{aligned}
++++

Where:

* stem:[\text{invoke}] is a constant prefix string, encoded in (ASCII).
* stem:[\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id].
* stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen-hash[Pedersen] hash

== Declare transaction

The declare transaction is used to introduce new classes into the state of StarkNet, enabling other contracts to deploy instances of those classes or using them in a library call. For more information, see xref:../Contracts/contract-classes.adoc[contract classes].

A declare transaction has the following fields:

[%autowidth]
|===
| Name | Type | Description

| `contract_class` | `ContractClass` | The class object.
| `sender_address` | `FieldElement` | The address of the account initiating the transaction.
| `max_fee` | `FieldElement` | The maximum fee that the sender is willing to pay for the transaction.
| `signature` | `List<FieldElement>` | Additional information given by the sender, used to validate the transaction.
| `nonce` | `FieldElement` | The transaction nonce.
| `version` | `FieldElement` | The transaction's version. Possible values are 1 or 0. +
When the fields that comprise a transaction change, either with the addition of a new field or the removal of an existing field, then the transaction version increases. Transaction version 0 is deprecated and will be removed in a future version of StarkNet.
|===

=== Calculating the hash of a v1 declare transaction

The hash of a v1 declare transaction is computed as follows:

[stem]
++++
\begin{aligned}
\text{declare_v1_tx_hash} = h( & ``\text{declare"}, \text{version}, \text{sender_address}, 0, \text{class_hash}, \text{max_fee}, \text{chain_id}, \text{nonce})
\end{aligned}
++++

Where:

* stem:[\text{declare}] is a constant prefix string, encoded in ASCII.
* stem:[\text{class_hash}] is the hash of the xref:../Contracts/contract-classes.adoc[contract class]. See xref:../Contracts/contract-hash.adoc[Contract Hash] for details about how the hash is computed.
* The placeholder zero is used to align the hash computation for the different types of transactions.
* stem:[\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id].
* stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen-hash[Pedersen] hash

=== Calculating the hash of a v0 declare transaction

The hash of a v0 declare transaction is computed as follows:

[stem]
++++
\begin{aligned}
\text{declare_v0_tx_hash} = h( & ``\text{declare"}, \text{version}, \text{sender_address}, 0, 0, \text{max_fee}, \text{chain_id}, \text{class_hash})
\end{aligned}
++++

Where:

* stem:[\text{declare}] is a constant prefix string, encoded in ASCII.
* The placeholder zeros are used to align the hash computation for the different types of transactions.
* stem:[\text{class_hash}] is the hash of the xref:../Contracts/contract-classes.adoc[contract class]. See xref:../Contracts/contract-hash.adoc[Contract Hash] for details about how the hash is computed.
* stem:[\text{chain_id}] is a constant value that specifies the network to which this transaction is sent. See xref:chain-id[Chain-Id].
* stem:[$h$] is the xref:../Hashing/hash-functions.adoc#pedersen-hash[Pedersen] hash

## Deploy account

Since xref:ROOT:version_notes.adoc#version0.10.1[StarkNet v0.10.1] the `deploy_account` transaction replaces the `deploy` transaction for deploying account contracts.

To use it, you should first add enough funds to your account address to pay the transaction fee, you can invoke `deploy _account`.

The following is an example of the new `deploy_account` transaction:

```json
{
	"class_hash": "0x53877052f990547ec7ca9dedec3a33ca321d3d45d2ca0790a1bb34bae52956e",
	"calldata": ["0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad"],
	"contract_address_salt": "0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad"
	"signature": [
		"0x2053a06585efce1c6e6e5cd9bbba774b78d872e727c310d972c7d885378d4fc",
		"0x53e0e3c6a515c1334d199a5a55fb8b5e0a1b5f678c36587e43c8f939f8ac99d"
	],
	"max_fee": "0xe0fbdace1bb7a",
	"type": "deploy_account",
	"nonce": 0,
	"version": 0
}
```

### Transaction flow

Upon receiving a `deploy_account` transaction, the sequencer will:

* verify that the address has funds to pay for the deployment
* execute the constructor with the given arguments
* execute the `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;` entry point
* charge fee from the new account address
* advance the nonce to 1

[NOTE]
====
In determining the contract address, deployer address 0 will be used.
====

### Validate deploy

A new validation entrypoint has been added to avoid being able to drain funds from a pre-funded address.

To see why this is important, consider the following example scenario:

Suppose that StarkNet has gas metering and that a sequencer may include a `deploy_account` transaction that charges the user according to the gas consumed in the constructor execution.

While the sequencer does not have the power to deploy a different contract for the user the address is xref:Contracts/contract-address.adoc[bound] to the class hash and constructor arguments, the sequencer does have the power to manipulate the price.

If the user does not sign a price (gas price, or in the present version of StarkNet, `max_fee`), then we must resort to schemes in the spirit of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md[EIP1559], to determine the deployment cost.

In this case, the sequencer can manipulate the block in order to charge an arbitrarily high fee and drain the user’s funds.

`&lowbar;&lowbar;validate_deploy`&lowbar;&lowbar; expects the following arguments:

* class hash
* contract address salt
* constructor arguments - the arguments expected by the contract’s constructor (this will be enforced in the compiler).

Consider an account with the following constructor signature:

```json
@constructor
func constructor{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    _public_key: felt
)
```

Then the signature of `&lowbar;&lowbar;validate_deploy`&lowbar;&lowbar; must be:

```json
func __validate_deploy__{
    syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin*
}(class_hash: felt, contract_address_salt: felt, _public_key: felt)
```

[NOTE]
====
The transaction hash and `max_fee` are accessible through the `get_tx_info` system call.
====

### Potential attacks and mitigations

We identify two major risks with the introduction of `deploy_account`:

* Sequencer DOS:
** If the account was not successfully created (constructor execution failed), then we can’t compensate the sequencer. We can’t simply take funds from the address as this introduces an easy attack on the user. To handle this issue, we will limit the execution of the constructor in the same manner that we limit the different validation entry points (`&lowbar;&lowbar;validate&lowbar;&lowbar;`, `&lowbar;&lowbar;validate_declare&lowbar;&lowbar;`, `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;`).

[NOTE]
====
These limits do not apply to regular constructor executions (i.e. those that are induced by the `deploy` system call).
====

** Draining the User’s funds:
We need to make sure that if a user pre-funded their account, then there is no way to drain those funds. Additionally, they must approve the amount they're willing to pay for the deployment. This is solved by the introduction of `&lowbar;&lowbar;validate_deploy&lowbar;&lowbar;`.

The limitations on validation/constructor execution involve:

* Limited # of Cairo steps
* Limited # of builtin applications
* No external contract calls (library calls and self-calls are allowed)

The precise limits are still being researched internally and will be shared in the future. In particular, we may block additional system calls that introduce the risk of validation being time-dependent, e.g. `get_block_timestamp` or `get_block_number`.

## API changes

In addition to the new transaction type, the following minor API changes apply since xref:ROOT:version_notes.adoc#version0.10.1[StarkNet version 0.10.1]:

* Renaming `contract_address` to `sender_address` in version 1 invoke transactions.
* The `entry_point_type` field is removed from invoke transactions (this affects the `get_block` and `get_transaction` feeder gateway endpoints). Note that this information is now reflected by the transaction type, hence the field is redundant.
* The `entry_point_selector` field is removed from version 1 invoke transactions.

== Signature

While StarkNet does not have a specific signature scheme built into the protocol, the Cairo language, in which smart contracts are written, does have an efficient implementation for ECDSA signature with respect to a xref:../Hashing/hash-functions.adoc#stark-curve[STARK-friendly curve].

The generator used in the ECDSA algorithm is stem:[G=\left(g_x, g_y\right)] where:

stem:[g_x=874739451078007766457464989774322083649278607533249481151382481072868806602] stem:[g_y=152666792071518830868575557812948353041420400780739481342941381225525861407]

[id="chain-id"]
== Chain-id

StarkNet currently supports three chain IDs. Chain IDs are given as numbers, representing the ASCII encoding of specific constant strings, as illustrated by the following Python snippet:

[source,python]
----
chain_id = int.from_bytes(value, byteorder="big", signed=False)
----
Three constants are currently used:

* `SN_MAIN` for StarkNet's main network.
* `SN_GOERLI` for StarkNet's public testnet.
* `SN_GOERLI2` for StarkNet developers.