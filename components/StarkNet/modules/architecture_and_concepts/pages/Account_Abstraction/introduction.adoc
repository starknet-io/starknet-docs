[id="account_abstraction"]
= Introduction to account abstraction

An account is a user's representation on-chain and his way of interacting with the blockchain. Through an account, a user may send transactions and interact with other contracts. To "own" an on-chain asset (e.g. ERC20 token or an NFT), it has to be associated with my account address.

The idea behind account abstraction is to allow more flexibility in the management of accounts rather than have their behavior determined at the protocol level. This can be achieved by introducing account contracts - smart contracts with programmable logic that determine the user's account.

Using account abstraction you can now program how your account functions. 

[id="ethereum_account_structure"]
== Ethereum account structure

Within Ethereum individual user accounts are known as Externally Owned Accounts (EOAs). 

EOAs differ from smart contracts in that they are not controlled by code. An EOA is determined by a pair of (private, public) keys. The account's address is determined from those keys, and only by possessing the private key can we initiate transactions from an account. While Ethereum contracts are "passive", i.e., they can only mutate if they were called inside a transaction, EOAs can initiate transactions.

While simple, EOAs have a major drawback: there's no flexibility in the account behavior. The Ethereum protocol dictates what it means for a transaction initiated by an EOA to be valid (the signature scheme is fixed). In particular, control over the public key gives complete control over the account.

Although this is theoretically a secure method of account management, in practice it has some drawbacks, such as requiring you to keep your seed phrase secure yet accessible to you, and limited flexibility surrounding wallet functionality.

EIP-4337, a design proposal for Ethereum outlines _account abstraction_ whereby all accounts are managed via a dedicated smart contract on the Ethereum network, as a way to increase flexibility and usability. You can add custom logic on top of the basic EOA functionality, thereby bringing account abstraction into Ethereum.

[id="what_is_an_account"]
== What is an account?

With account abstraction, you can now program how your account functions. For example, you can:

*   Determine what it means for a signature to be valid or what contracts your account is allowed to interact with. This is known as "signature abstraction"

*   Design your own replay protection mechanism and allow sending multiple uncoupled transactions in parallel. Compare this to the sequential nonce solution used in Ethereum, which results in transactions being inherently sequential, i.e., even if one wants to send two transactions in parallel, he must wait for some confirmation on the first before sending the second. Otherwise, the second transaction may be rejected due to an invalid nonce. With account abstraction, one can discuss different solutions that bypass the need for a sequential nonce. This is known as "nonce abstraction"

*   Pay transaction fees in different tokens - this is sometimes known as "fee abstraction"

Today, StarkNet offers signature abstraction. In the future, we will enrich the current account abstraction design (see e.g. the https://community.starknet.io/t/starknet-account-abstraction-model-part-1/781[paymaster proposal] for fee abstraction).