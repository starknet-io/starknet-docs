[id="validate_and_execute_functions"]
== `&lowbar;&lowbar;validate&lowbar;&lowbar;` and `&lowbar;&lowbar;execute&lowbar;&lowbar;` functions

A StarkNet account contract must include the following two functions:

* `&lowbar;&lowbar;validate&lowbar;&lowbar;`
* `&lowbar;&lowbar;execute&lowbar;&lowbar;`

These serve distinct purposes to ensure that only the account owner can initiate transactions and that fair fees are charged for the resources you use.

[id="starknet_account_structure"]
== StarkNet account structure

Starknet's account type is inspired by Ethereum's EIP-4337, where instead of EOAs, you now use smart contract accounts with arbitrary verification logic. 

Through the use of smart contracts, you are provided with complete flexibility within your account implementation.

[id="examples"]
== Examples of customizing account functionality

Two examples of how you might program an account to function using account abstraction are:

Social recovery:: A process where if you lose your wallet, you are able to retrieve it via a selected social network, vastly improving the typical experience of wallet recovery.

Operating your account via facial recognition:: With signature abstraction, you can use your phone's native hardware to sign transactions, making it practically impossible to take control of another user's account (even in the case of the phone itself being stolen).

[id="replay_protection"]
== Replay protection

In StarkNet, similar to Ethereum, every contract has a nonce. This nonce is sequential; when a transaction is sent from an account, its nonce must match the account's nonce and it's incremented after the transaction is executed (whether or not it was reverted). 

Note that, similar to Ethereum, only the nonce of account contracts (that is, those adhering to the above structure) can be non-zero.

A nonce serves two important roles:

*   It guarantees transaction hash uniqueness (this is important for good UX)
*   It provides replay protection to the account (since the signature refers to a particular nonce, the transaction can't be replayed by a malicious party)

As seen above, StarkNet currently determines the nonce structure (sequential) at the protocol level. In the future, StarkNet consider a more flexible design, extending account abstraction to nonce management (previously referred to as "nonce abstraction").

While not mandatory at the protocol level, a richer standard interface for accounts was developed by the community. This standard was developed by OpenZeppelin, in a close collaboration with wallet teams and other Core StarkNet developers. You can see the IAccount interface https://github.com/OpenZeppelin/cairo-contracts/blob/main/src/openzeppelin/account/IAccount.cairo[here].

[id="validate_limitations"]
== Validate limitations

There are some limitations set on the `&lowbar;&lowbar;validate&lowbar;&lowbar;` function. The purpose of these limitations is twofold:

*   We want to avoid the sequencer having to do a lot of work only to discover that the validation failed and the sequencer is then not eligible to charge a fee (if this was possible, the sequencer would be completely exposed to DOS attacks). Validation, while now abstract and in control of the account owner rather than the protocol, should still be a simple operation. This is why in the future, StarkNet will place max steps limitation upon the `&lowbar;&lowbar;validate&lowbar;&lowbar;` function.

*   Even if the validation is simple, we could still face the following attack: 
    **  An attacker fills the mempool with transactions that are valid at time T. 
    **  A sequencer may start executing them, thinking that at the time he will produce his block, they will still be valid. 
    **  However, shortly after, at time T', the attacker sends one transaction that somehow invalidates all the previous ones and makes sure it's included before the sequencer gets to publish his block (the attacker may do this by offering higher fees for this one transaction). 

As a concrete example, think of many `&lowbar;&lowbar;validate&lowbar;&lowbar;` functions checking that the value of a storage slot is 1 and the attacker's transaction later sets it to 0. To handle this issue, we add some further limitations. Currently, StarkNet enforces that `&lowbar;&lowbar;validate&lowbar;&lowbar;` does not call external contracts.

NOTE: The property that we achieve with the above restrictions is that a single storage update may only invalidate transactions from a single account (this is the best we can do, an account can always invalidate its own past transactions by changing its keys). Thus, the price (in fees) required to invalidate transactions in the mempool is linear in the number of unique accounts that we want to invalidate.