[id="writing_contracts"]

= Writing a Starknet smart contract

== Overview

This section, will run through in more detail how to write a Starknet smart contract using Cairo.

This example contract is a simple read/write contract that will illustrate how to read
and write from storage using Cairo.

The contract will be called `SimpleStorage`.

== Step 1: Contract macro and modules

Create a new folder to store this new contract or create it inside your `.cairo/` folder.


Create a new file and call it `simple_storage.cairo`.

[,Bash]
----
touch simple_storage.cairo
----

You can open this empty file in your editor of choice (eg: VS Code) and start creating the smart
contract.

A Starknet contract will always start with the `[#contract]` macro to indicate that this is a Starknet contract.

[NOTE]
=====
You can also create other Cairo files that are *NOT* contracts because Cairo is a
programming language by itself.
=====

All the Cairo contracts are defined by the keyword `mod` which implies that it's a module containing some logical piece of code.

Add the following lines of code to the newly created `simple_storage.cairo` file:

[,Bash]
----
#[contract]
mod SimpleStorage {}
----

== Step 2: Creating the Storage

In order to store variables on-chain, we need to create a storage structure called `Storage`.
This struct will have all the variables that you would like to have in contract/permanent storage.

Create a Storage struct within your `SimpleStorage` contract as shown below.

[,Bash]
----
struct Storage {
       balance: felt252
}
----

____

NOTE: The storage struct will always be named `Storage`.
____

== Step 3: Defining events

You can define an event just like a function with the name of the event.

Add an event named `BalanceIncreased` and the values you would like to emit within the bracket
as arguments.

[,Bash]
----
//The keyword to define a function is "fn"
 #[event]
 fn BalanceIncreased(balance: felt252) {}
----

== Step 4: Writing your first function

Below is a simple function called `increase_balance` which takes in the amount as the argument of type `felt252`.


The function is fairly simple. We read the balance variable (defined earlier in the storage
struct) using `::read()` function and simply increase the balance by adding the amount to it.

We then write the new balance to the existing storage variable and update the value.

We then log/emit the event with the updated balance using the name of the event function.

[,Bash]
----
  #[external]
  fn increase_balance(amount: felt252) {
      let new_balance = balance::read() + amount;
      balance::write(new_balance);
      BalanceIncreased(new_balance);
  }
----

We have also added a macro called `external` that is added to this function. This means that the
function called be called externally or outside of the contract.

For functions that are modifying a storage variable, you would need to add the external macro.

There are other types of macros as well that you can add to a function:

    * event
    * external
    * view
    * constructor

== Step 5: Writing a view function

As you saw in Step 4, we are able to write to our storage using `balance::write()`, we can also
read from storage using a read function.

In the below function, we are reading the current balance of the storage variable _balance_ and
returning it. You can observe that we use a `->` symbol to return the variable, similar to
link:https://www.rust-lang.org/learn[Rust].

This function can be a `view` function because it does not modify any variables.

[,Bash]
----
  #[view]
  fn get_balance() -> felt252 {
       balance::read()
  }
----

== Step 6: The final contract

The final contract should look similar to the below code snippet:

[,Bash]
----
#[contract]
mod SimpleStorage {
   struct Storage {
       balance: felt252
   }

   #[event]
   fn BalanceIncreased(balance: felt252) {}

   #[external]
   fn increase_balance(amount: felt252) {
      let new_balance = balance::read() + amount;
      balance::write(new_balance);
      BalanceIncreased(new_balance);
   }

   #[view]
   fn get_balance() -> felt252 {
       balance::read()
   }
}
----

You can now follow the steps given in the xref:cairo_1/deploying_contracts.adoc[Deploying smart contracts] section to compile and
deploy the
above contract.
