[id="fact_registry_contracts"]
= Fact Registry Contracts

:stem: latexmath

[id="fact_registry"]
== Fact Registry

The Fact Registry design pattern is a way to separate statements verification from the business logic of the contract flow.

A fact registry holds a hash table of verified "`facts`" which are represented by a hash of claims that the registry has checked and found valid. This table may be queried by accessing the https://github.com/starkware-libs/starkex-contracts/blob/e42fedeb2d6a262edc7ed5086e4cecddc2df087e/scalable-dex/contracts/src/components/FactRegistry.sol#L16[`isValid`] function of the registry with a given hash.

In addition, each fact registry exposes a registry specific function for submitting new claims together with their proofs. The information submitted varies from one registry to the other depending of the type of fact requiring verification.

For further reading on the Fact Registry design pattern see this https://medium.com/starkware/the-fact-registry-a64aafb598b6[blog post].

StarkEx uses the following fact registries:

*  xref:fact-registry.adoc#stark-verifier-for-cairo-programs[STARK Verifier for Cairo Programs]
*  xref:fact-registry.adoc#committee-signature-verifier[Committee Signature Verifier]
*  xref:fact-registry.adoc#escape-verifier[Escape Verifier]

[id="stark_verifier_for_cairo_programs"]
== STARK Verifier for Cairo Programs

https://github.com/starkware-libs/starkex-contracts/blob/e42fedeb2d6a262edc7ed5086e4cecddc2df087e/evm-verifier/solidity/contracts/gps/GpsStatementVerifier.sol#L57[Verifies] programs that are written in Cairo. Specifically, it verifies the computational integrity of executing a Cairo program `P` on an input data `D`, and the correctness of the post-execution state of the system.

The verifier gets as part of the input a hash of the program _`P`_.

[id="committee_signature_verifier"]
== Committee Signature Verifier

https://github.com/starkware-libs/starkex-contracts/blob/e42fedeb2d6a262edc7ed5086e4cecddc2df087e/scalable-dex/contracts/src/committee/Committee.sol#L50[Verifies] the availability proof in xref:data-availability-modes.adoc#validium[Validium]. Reverts if invalid. An availability proof should have a form containing a concatenation of signatures by signatories. Signatures should be sorted in ascending order by signatory address. Signatures should be 65 bytes long. r(32) + s(32) + v(1). There should be at least the number of required signatures as https://github.com/starkware-libs/starkex-contracts/blob/e42fedeb2d6a262edc7ed5086e4cecddc2df087e/scalable-dex/contracts/src/committee/Committee.sol#L11[defined] in this contract and all signatures provided should be from signatories.

See xref:fact-registry.adoc[`Availability Verifiers`] for more information on when this is used.

[id="escape_verifier"]
== Escape Verifier

https://github.com/starkware-libs/starkex-contracts/blob/e42fedeb2d6a262edc7ed5086e4cecddc2df087e/scalable-dex/contracts/src/starkex/components/EscapeVerifier.sol#L105[Verifies] that the contents of a vault belong to a certain Merkle commitment (root).

The Merkle commitment uses the Pedersen hash variation described next:

* *Hash constants:* A sequence stem:[p_i] of 504 points on an elliptic curve and an additional stem:[ec_{shift}] point
* *Input:* A vector of 504 bits stem:[b_i]
* *Output:* The 252 bits x coordinate of stem:[(ec_{shift} + \sum_i b_i*p_i)]g

The following table describes the expected `escapeProof` format. Note that unlike a standard Merkle proof, the `escapeProof` contains both the nodes along the Merkle path and their siblings. The proof ends with the expected root and the ID of the vault for which the proof is submitted (which implies the location of the nodes within the Merkle tree).

|===
|  |  |

| starkKey (252)
| assetId (252)
| zeros (8)

| hash(starkKey, assetId) (252)
| quantizedAmount (252)
| zeros (8)

| left_node_0 (252)
| right_node_0 (252)
| zeros (8)

| ...
|
|

| left_node_n (252)
| right_node_n (252)
| zeros (8)

| root (252)
| zeros (4) \| vaultId (248)
| zeros (8)
|===

If the proof is accepted, this is registered under the following claim hash that may later be queried for validity:

`claimHash = keccak256(starkKey, assetId, quantizedAmount, vaultRoot, treeHeight, vaultId)`

See xref:README-in-spot-trading.adoc[`Escapes`] for more information on when this is used.
